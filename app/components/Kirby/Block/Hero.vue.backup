<script setup lang="ts">
import type { KirbyBlock } from '#nuxt-kql'
import type { ResolvedKirbyImage } from '../../../../shared/types/kirby'
import { computed } from 'vue'
import { useMarkdownParser } from '@/composables/useMarkdownParser'

const props = defineProps<{
  block: KirbyBlock<
    'hero',
    {
      heading?: string
      heading_size?: string
      heading_style?: string
      heading_alignment?: 'up' | 'down'
      subheading?: string
      subheading_style?: string
      date?: string
      date_style?: string
      text?: string
      text_style?: string
      backgroundcolor?: string
      secondarybackgroundcolor?: string
      textcolor?: string
      secondarytextcolor?: string
      text_shadow?: 'shadow_dark' | 'shadow_light'
      coverimage?: ResolvedKirbyImage[]
      hero_layout?: 'left' | 'right' | 'centered'
      hero_fade?: 'top' | 'bottom'
      object_fit?: 'cover' | 'contain' | 'none'
      image_alignment?: 'up' | 'down'
      kenburns?: 'effect_on' | 'effect_off'
      // File UUIDs are resolved server-side to the actual image data
      // See: https://kirby.tools/docs/headless/field-methods
    }
  >
}>()
const page = usePage()
const _invert = computed(() => page.value.invert)

const coverImage = computed(() => {
  // Return the image data directly if it's a single object, otherwise return the array
  if (
    props.block.content.coverimage &&
    !Array.isArray(props.block.content.coverimage)
  ) {
    return [props.block.content.coverimage]
  }
  return props.block.content.coverimage
})

const imageData = computed(() => {
  // Handle both array and single object cases
  if (coverImage.value && coverImage.value.length > 0) {
    return coverImage.value[0]
  }
  return null
})

const heading = computed(() => props.block.content.heading || '')
const subheading = computed(() => props.block.content.subheading)
const text = computed(() => props.block.content.text)
const date = computed(() => props.block.content.date)

// Format date as dd.mm.YYYY
const formattedDate = computed(() => {
  if (!props.block.content.date) return ''

  const dateObj = new Date(props.block.content.date)
  if (Number.isNaN(dateObj.getTime())) return props.block.content.date // Return original if invalid

  const day = dateObj.getDate().toString().padStart(2, '0')
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0')
  const year = dateObj.getFullYear()

  return `${day}.${month}.${year}`
})

// Computed properties for styling
const backgroundStyle = computed(() => {
  const primaryColor = props.block.content.backgroundcolor || 'transparent'
  const secondaryColor = props.block.content.secondarybackgroundcolor

  if (secondaryColor) {
    return {
      background: `linear-gradient(to bottom, ${primaryColor}, ${secondaryColor})`,
    }
  }

  return {
    backgroundColor: primaryColor,
  }
})

const textColorStyle = computed(() => ({
  color: props.block.content.textcolor || 'inherit',
}))

const h2Color = computed(() => ({
  color: props.block.content.secondarytextcolor || 'inherit',
}))

// Computed properties for layout classes
const containerClasses = computed(() => {
  const layout = props.block.content.hero_layout || 'left'
  if (layout === 'centered') {
    return 'hero w-full h-full -ml-2 md:ml-0 top-0 left-0'
  }
  return 'hero w-screen sm:grid sm:grid-cols-12 -ml-2 md:ml-0 md:h-full md:w-full'
})

const imageClasses = computed(() => {
  const layout = props.block.content.hero_layout || 'left'
  if (layout === 'centered') {
    return 'column group m-0 overflow-hidden inset-0 w-full h-full'
  }
  return `column group col-span-12 m-0 overflow-hidden md:col-span-6 ${layout === 'right' ? 'md:order-2' : ''}`
})

const contentClasses = computed(() => {
  const layout = props.block.content.hero_layout || 'left'
  const alignment = props.block.content.heading_alignment
  if (layout === 'centered') {
    // Default: center, up: top, down: bottom
    if (alignment === 'up') {
      return 'column not-prose absolute inset-0 flex flex-col items-center justify-start pt-[22vh] z-10 w-full h-full'
    } else if (alignment === 'down') {
      return 'column not-prose absolute inset-0 flex flex-col items-center justify-end pb-[10vh] z-10 w-full h-full'
    }
    return 'column not-prose absolute inset-0 flex flex-col items-center justify-center z-10 w-full h-full'
  }
  // Default: center, up: top, down: bottom
  let base = `column not-prose grid col-span-12 justify-center justify-items-center text-center md:col-span-6 ${layout === 'right' ? 'md:order-1' : 'md:order-2'}`
  if (alignment === 'up') {
    base += ' items-center pt-[22vh]'
  } else if (alignment === 'down') {
    base += ' items-center pb-[5vh]'
  } else {
    base += ' items-center py-12'
  }
  return base
})

// Computed property for image focus style
const imageStyle = computed(() => {
  if (!imageData.value) return {}
  const style: Record<string, string> = {}
  // Object fit
  style.objectFit = objectFit.value
  // Focus
  if (imageData.value.focus) {
    style.objectPosition = imageData.value.focus
  } else if (imageData.value.focusX && imageData.value.focusY) {
    style.objectPosition = `${imageData.value.focusX}% ${imageData.value.focusY}%`
  } else if ((objectFit.value === 'cover' || objectFit.value === 'contain') && props.block.content.image_alignment) {
    // Default object position for alignment
    if (props.block.content.image_alignment === 'up') {
      style.objectPosition = 'center 0%'
    } else if (props.block.content.image_alignment === 'down') {
      style.objectPosition = 'center 100%'
    }
  }
  // If object-fit is 'none', don't stretch image
  if (objectFit.value === 'none') {
    style.width = 'auto'
    style.height = 'auto'
    style.maxWidth = '100%'
    style.maxHeight = '100%'
  }
  return style
})

// Font class helper
const fontClass = (style?: string) => {
  switch (style) {
    case 'font-serif':
      return 'font-serif'
    case 'font-mono':
      return 'font-mono'
    default:
      return 'font-sans'
  }
}
// Font size helper for heading
const headingSizeClass = (size?: string) => {
  switch (size) {
    case 'text-3xl':
    case 'text-2xl':
    case 'text-xl':
    case 'text-lg':
    case 'text-m':
      return size
    default:
      return 'text-xl'
  }
}

// Fade overlay computed
const heroFade = computed(() => props.block.content.hero_fade)

// Object fit computed
const objectFit = computed(() => props.block.content.object_fit || 'cover')

// Text shadow computed
const textShadowClass = computed(() => {
  const shadow = props.block.content.text_shadow
  if (!shadow) return ''

  switch (shadow) {
    case 'shadow_dark':
      return 'text-shadow-dark'
    case 'shadow_light':
      return 'text-shadow-light'
    default:
      return ''
  }
})

// Tailwind classes for image based on object_fit
const imageTailwindClasses = computed(() => {
  switch (objectFit.value) {
    case 'cover':
      return ['object-cover', 'h-full', 'w-screen']
    case 'contain':
      return ['object-contain', 'h-full', 'w-screen']
    case 'none':
      return ['max-w-full', 'max-h-full']
    default:
      return ['object-cover', 'h-full', 'w-screen']
  }
})
</script>
<template>
  <div class="h-screen min-h-[100]" :class="containerClasses" :style="backgroundStyle">
    <figure v-if="imageData" :class="imageClasses" class="w-full h-screen;">
      <img :class="[
        { kenburns: props.block.content.kenburns === 'effect_on' },
        { 'hero-fade-top': heroFade === 'top' },
        { 'hero-fade-bottom': heroFade === 'bottom' },
        ...imageTailwindClasses
      ]" loading="lazy" :src="imageData.url" :srcset="imageData.srcset" :width="imageData.width"
        :height="imageData.height" sizes="(min-width: 640px) 50vw, 100vw" :alt="imageData.alt || ''"
        :style="imageStyle" />
    </figure>

    <div :class="contentClasses">
      <div class="column px-12 text-center">
        <h1 class="m-auto pb-0 md:max-w-[22ch] leaading-tight"
          :class="[fontClass(props.block.content.heading_style), headingSizeClass(props.block.content.heading_size), textShadowClass]"
          v-html="heading" />
        <h2 v-if="subheading" :style="h2Color" class="text-md pb-0 pt-4"
          :class="fontClass(props.block.content.subheading_style)" v-html="subheading" />
        <span v-if="date" class="text-base opacity-85 lg:text-base pt-4"
          :class="fontClass(props.block.content.date_style)" :datetime="date">{{ formattedDate }}</span>
        <div v-if="text" class="pt-4" :class="fontClass(props.block.content.text_style)" v-html="text" />
      </div>
    </div>
  </div>
</template>

<style scoped>
@keyframes kenburns {
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(1.1);
  }

  100% {
    transform: scale(1);
  }
}

.kenburns {
  animation: kenburns 45s ease-in-out infinite;
}

.hero-fade-top {
  mask: linear-gradient(to bottom, transparent 0%, black 30%);
  -webkit-mask: linear-gradient(to bottom, transparent 0%, black 30%);
}

.hero-fade-bottom {
  mask: linear-gradient(to top, transparent 0%, black 30%);
  -webkit-mask: linear-gradient(to top, transparent 0%, black 30%);
}

.text-shadow-dark,
.text-shadow-dark:hover,
.text-shadow-dark:focus,
.text-shadow-dark:active {
  text-shadow:
    0 0 4rem rgba(0, 0, 0, 0.9),
    0 0 8rem rgba(0, 0, 0, 0.7),
    0 0 12rem rgba(0, 0, 0, 0.5),
    0.125rem 0.125rem 1rem rgba(0, 0, 0, 0.8) !important;
  transition: none !important;
}

.text-shadow-light,
.text-shadow-light:hover,
.text-shadow-light:focus,
.text-shadow-light:active {
  text-shadow:
    0 0 4rem rgba(255, 255, 255, 0.9),
    0 0 8rem rgba(255, 255, 255, 0.7),
    0 0 12rem rgba(255, 255, 255, 0.5),
    0.0625rem 0.0625rem 1rem rgba(255, 255, 255, 0.8) !important;
  transition: none !important;
}

/* Override global heading padding */
h1,
h2,
h3,
h4,
h5,
h6 {
  padding-bottom: 0 !important;
}
</style>